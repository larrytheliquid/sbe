\documentclass[preprint,nonatbib]{sigplanconf}
\usepackage[authoryear,square]{natbib}
\usepackage{proof}

\usepackage{todonotes}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{url}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{stmaryrd}
\usepackage{enumitem}
\usepackage[all]{xy}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{8759}{\ensuremath{\colon\colon}}
\DeclareUnicodeCharacter{12314}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{12315}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{8614}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{?}{=}}}
\DeclareUnicodeCharacter{8669}{\ensuremath{\leadsto}}

\DeclareUnicodeCharacter{7496}{\ensuremath{^{d}}}

\usepackage{fancyvrb}

\usepackage[labelfont=bf]{caption}

\newtheorem{mydfn}{Definition}
\newtheorem{mysubdfn}{Case}
\numberwithin{mysubdfn}{mydfn}

\newtheorem{mythm}{Theorem}
\newtheorem{mylem}{Lemma}

\newcommand{\refdef}[1]{Definition \ref{dfn:#1}}
\newcommand{\refthm}[1]{Theorem \ref{thm:#1}}
\newcommand{\reflem}[1]{Lemma \ref{lem:#1}}

\newtheorem{mydef}{Definition}
\newtheorem{myparte}{Part$_E$}
\newtheorem{myparti}{Part$_I$}

\newcommand{\reffig}[1]{Figure \ref{fig:#1}}
\newcommand{\refsec}[1]{Section \ref{sec:#1}}
\newcommand{\refparte}[1]{Part$_E$ \ref{parte:#1}}
\newcommand{\refparti}[1]{Part$_I$ \ref{parti:#1}}

\def\dfn{\mapsto}
\def\bigstep{\Downarrow}
\def\arr{\supset}
\def\marr{\rightarrow}
\def\app{\cdot}
\def\lam{\lambda}
\def\nat{\mathbb{N}}

\newcommand{\ascribe}[2]{(#1 : #2)}
\newcommand{\all}[1]{\forall#1.~}
\newcommand{\ex}[1]{\exists#1.~}

\newcommand{\el}[1]{\llbracket ~ #1 ~ \rrbracket}

\newcommand{\con}[1]{\textmd{#1}}
\newcommand{\fun}[1]{\textmd{#1}}

\newcommand{\typm}[1]{\el{\Gamma \vdash #1}}
\newcommand{\dtypm}[1]{\el{\Delta \vdash #1}}
\newcommand{\ctypm}[2]{\el{\Gamma , #1 \vdash #2}}

\newcommand{\type}[1]{\Gamma \vdash^E #1}
\newcommand{\dtype}[1]{\Delta \vdash^E #1}
\newcommand{\ctype}[2]{\Gamma , #1 \vdash^E #2}

\newcommand{\typv}[1]{\Gamma \vdash^V #1}
\newcommand{\dtypv}[1]{\Delta \vdash^V #1}
\newcommand{\ctypv}[2]{\Gamma , #1 \vdash^V #2}

\newcommand{\typn}[1]{\Gamma \vdash^N #1}
\newcommand{\dtypn}[1]{\Delta \vdash^N #1}
\newcommand{\ctypn}[2]{\Gamma , #1 \vdash^N #2}

\newcommand{\typr}[1]{\Gamma \vdash^R #1}
\newcommand{\dtypr}[1]{\Delta \vdash^R #1}
\newcommand{\ctypr}[2]{\Gamma , #1 \vdash^R #2}

\newcommand{\ren}[1]{\Gamma \le #1}
\def\dren{\ren{\Delta}}
\newcommand{\env}[1]{\Gamma \sqsubseteq #1}
\def\denv{\env{\Delta}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\titlebanner{DRAFT}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Proof Pearl: Hereditary Substitution by Canonical Evaluation}
\subtitle{Termination Proofs as Intrinsic Semantics}

\authorinfo{Larry Diehl\and Tim Sheard}
           {Portland State University}
           {\{ldiehl,sheard\}@cs.pdx.edu}

\maketitle

\begin{abstract}
This paper is first about a change in perspective: thinking about
termination proofs as defining an {\it intrinsic semantics}, resulting
in simpler metatheoretical definitions and providing free theorems.
This is analogous to the benefits obtained from taking advantage of
{\it intrinsic typing}.
The paper is second about showing how
adopting this change in perspective helped us prove a novel result:
that hereditary substitution for G{\"o}del's System T terminates.
\end{abstract}

\category{D.3}{Software}{Programming Languages}.

\keywords
Type theory; hereditary substitution; termination; formalization.

\section{Introduction}
\label{sec:intro}

As type theorists we often find ourselves in the following situation.
We write down the typing rules and semantics for some total lambda
calculus as relations. 
We then proceed to prove easy metatheorems like type safety (which is merely
preservation for a big-step semantics).

\paragraph{Big-Step Type Preservation}

$$
\all{\ascribe{e}{A}} e \bigstep e' \marr \ascribe{e'}{A}
$$



Unfortunately, our relationally specified semantics is not obviously
terminating, so we begin the more difficult task of proving its
termination.

\paragraph{Big-Step Termination}

$$
\all{\ascribe{e}{A}} \ex{\ascribe{e'}{A}} e \bigstep e' \land \fun{IsValue}(e')
$$

To prove termination, we come up with the appropriate logical
relation~\cite{TODO} for our semantics, relating expressions to evidence
that they terminate as some value.
In this case we have a unary
logical relation on expressions, or a realizability
predicate~\cite{TODO}. You can prove termination as the composition of
evaluation of expressions into the logical relation, and reification
of termination evidence back out of of it.

\begin{displaymath}
    \xymatrix{
          {\forall (e : A)} 
          \ar[dr]_{\fun{termination}}
          \ar[r]^{\fun{evaluate}}
        & {\el{A}(e)}
          \ar[d]^{\large{\fun{reify}}}
\\      & {\exists (e' : A). ~ e \bigstep e' \wedge \fun{IsValue} ~ e'} }
\end{displaymath}

Many operational semantics have been proven to terminate using this
method. For example, the realizability predicate and associated lemmas
needed to prove that a big-step semantics terminates for G{\"o}del's
System T are well known. It is easy to understand and verify such
completed definitions and proofs, but coming up with the correct
realizability predicate and associated lemmas for a novel proof takes
ingenuity. 

As we got stuck in various places trying to prove a novel termination result
(that {\it hereditary substitution}~\cite{TODO} terminates for
G{\"o}del's System T), we were inspired by
{\it intrinsic typing}~\cite{TODO} as a means of simplifying our
metatheory and getting free theorems. With {\it extrinsic} typing you
define expressions, a separate extrinsic typing relation, and prove
theorems of the form:
$$
\all{\ascribe{e}{Exp}} \ascribe{e}{A} \marr ...
$$

Rather than having this pair of argument everywhere, you can define
terms as an {\it intrinsic} typing relation, simplifying theorems to
have the form:
$$
\all{\ascribe{e}{A}} \marr ...
$$

Furthermore, as our big-step semantics is now defined on intrinsically
typed expressions, the result is already type-correct so we get the
theorem of {\bf Type Preservation} for {\it free}!

{\bf Now to the point:} 
Recall the ``termination'' arrow in the commutative diagram for our
logical relations proof above. By analogy to intrinsic typing, you
can think of the big-step relation on expressions as an
{\it extrinsic semantics}, and the termination proof as a function
that produces a witness that the extrinsic semantics terminates. Yet,
the termination proof can itself act as an {\it intrinsic semantics}! 
Just like with intrinsic typing, when we use an intrinsic semantics
statements of theorems become simplified. For example, we can rename
and restate our previous {\bf Termination} theorem, to more
appropriately reflect that it {\it defines} normalization (our
semantics) as a function from expressions of some type to values of
the same type:

\paragraph{Big-Step Normalization}
$$
\all{\ascribe{e}{A}} \ex{\ascribe{v}{A}}
$$

By the same token, our diagram is also simplified.

\begin{displaymath}
    \xymatrix{
          {\forall (e : A)} 
          \ar[dr]_{\fun{normalize}}
          \ar[r]^{\fun{evaluate}}
        & {\el{A}}
          \ar[d]^{\large{\fun{reify}}}
\\      & \exists (v : A) }
\end{displaymath}

Notice the codomain of evaluation has become simpler. Formerely, it
was a realizability predicate ($\el{A}(e)$) that related the input
expression to the underlying extrinsic big-step semantics. Now, it has
become a Kripke model~\cite{TODO} ($\el{A}$) representing the
collection of {\it values} of the appropriate type! Thus, the normalization
theorem is the well-known technique of defining your (intrinsic)
semantics as Normalization by Evaluation (NbE)~\cite{TODO}.

\paragraph{}
Our {\bf contributions} are as follows:

\subsection{The Perspective of Termination Proofs as Intrinsic Semantics}

The relationship between realizability predicates and Kripke models is
readily apparent. Neither of these concepts are new, we merely wish
to point out that NbE falls out of thinking of the
realizability predicate-based termination proof of an {\it extrinsic}
operational semantics as already defining an {\it intrinsic}
semantics.

Just like intrinsic typing, intrinsic semantics simplifies statements
of theorems. Moreover, intrinsic semantics also provides us with
{\it free} theorems, as shown in \refsec{TODO} and \refsec{TODO}!

\paragraph{Big-Step Determinacy}

$$
e \bigstep e' \marr e \bigstep e'' \marr e' \equiv e''
$$

Because our termination proof-based semantics is already a function,
we do not need to prove that it produces unique outputs.

\paragraph{Big-Step Predicate Preservation}

$$
\el{A}(e) \marr e \bigstep e' \marr \el{A}(e')
$$

One of the theorems of a realizability predicate-based proof of
big-step semantics shows that the semantics preserves satisfiability
of the predicate. This is analogous to type-preservation, but at the
level of the realizability predicate. Because an intrinsic semantics
does not need to thread through evidence of an extrinsic semantics, we
also get this theorem for free.

\subsection{Termination of Hereditary Substitution for G{\"o}del's System T}



For example, instead of giving a big-step semantics to
{\it expressions}, we might want to give a semantics to
{\it values} of a canonical type theory. The semantics for values is
known as {\it hereditary substitution}~\cite{TODO}, which substitutes
values for variables in a value, but performs evaluation if substitution would
result in a $\beta$-redex (which would break the invariant that values
do not contain $\beta$-redexes). 

Termination of operational semantics has been proven using these
methods for 
Many lambda calculi, such as 
If someone has already proven termination 
If someone shows you the definition of a realizability predicate, and the
theorems and proofs for 

It is easy to understand the definition of the logical relation

\section{Background}
\label{sec:background}

\todo[inline]{To set the scene for this paper, we begin with a brief overview of...}
\todo[inline]{Show big step termination problem case}

\begin{displaymath}
    \xymatrix{
          {\forall (v : A), \sigma} 
          \ar[dr]_{\fun{hsub}}
          \ar[r]^{\fun{ceval}}
        & {\el{A}(v)}
          \ar[d]^{\large{\fun{reify}}}
\\      & {\exists (v' : A). ~ [ \sigma ] v = v'} }
\end{displaymath}

\begin{displaymath}
    \xymatrix{
          {A, \sigma} 
          \ar[dr]_{\fun{hsub}}
          \ar[r]^{\fun{ceval}}
        & {\el{A}}
          \ar[d]^{\large{\fun{reify}}}
\\      & {A} }
\end{displaymath}

\begin{mydfn}[Big-Step Realizability Predicate]
$ $\\
For any context $\Gamma$ and type $A$, the predicate on the expression
$(a : \type{A})$ is $\typm{A}(a)$.

\begin{mysubdfn}[Natural numbers]
$\typm{\nat}(n)$
$$
\exists (n' : \type{\nat}).~ n \bigstep n' \wedge \fun{IsValue} ~ n'
$$
For natural numbers we require a proof that $n$ evalutes to
some normal term $n'$ .
\end{mysubdfn}


\begin{mysubdfn}[Functions]
$\typm{A \arr B}(f)$
\begin{align*}
\forall \Delta.&~ \dren \marr (a : \dtype{A}) \marr \\
&\dtypm{A}(a) \marr \dtypm{B}(\fun{ren}^E ~ \Delta ~ f \app a)
\end{align*}


%% $$
%% \forall \Delta.~ \dren \marr (a : \dtype{A})
%% \marr \dtypm{A}(a) \marr \dtypm{B}(\fun{ren}^E ~ \Delta ~ f \app a)
%% $$

For functions we require that for any weakened proof that $a$
is realized, a proof that a weakened version of $f$ applied to
$a$ is also realized.
\end{mysubdfn}

\end{mydfn}

\begin{mythm}[Predicate Reflection]
$$\forall (a : \type{A}).~ \fun{IsNeutral} ~ a \marr \typm{A}(a)$$
\end{mythm}

\begin{mythm}[Predicate Preservation]
$$
\forall (a ~ a' : \type{A}).~ \typm{A}(a) \marr 
a \bigstep a' \marr \typm{A}(a')
$$
\end{mythm}

\begin{mythm}[Predicate Reification]
$$
\forall (a : \type{A}).~ \typm{A}(a) \marr
\exists (a' : \type{A}).~ a \bigstep a' ~ \wedge ~ \fun{IsValue} ~ a'
$$
\end{mythm}

\begin{mythm}[Predicate Evaluation]
$$
\forall (a : \type{A}) (\sigma : \denv).~ \dtypm{A}(\sigma ~ a)
$$
\end{mythm}




\begin{align*}
&\typm{A \arr B}& &\dfn \forall \Delta.~ \dren \marr \dtypm{A} \marr \dtypm{B} \\
&\typm{A}& &\dfn \typv{A}
\end{align*}




%% \begin{displaymath}
%%     \xymatrix{
%%           {\forall (v : \typv{A}) (\sigma : \denv)} \ar[dr] 
%%             \ar[r]
%%         & {\dtypm{A}} \ar[d]
%% \\      & {\exists (v' : \dtypv{A}). ~ [ \sigma ] v = v'} }
%% \end{displaymath}

\todo[inline]{big picture:}
\todo[inline]{

This paper is about 2 things:
1. Reducing the complexity of metatheory statements, and the number of
proofs necessary in the metatheory. This is done by analogy with
intrinsic typing, where we consider intrinsic semantics. Here we do
not introduce any new techniques, we just offer a change of
perspective and clarify what savings we get. In the scenario in
question this amounts to shifting from an extrinsic relational semantics and a
realizability predicate (here a unary logical relation) used to prove
termination, to an intrinsic functional semantics using a Kripke model
(which can be seen as a nullary logical relation).

2. Adopting the perspective of intrinsic semantics in order to simply prove
termination of hereditary substitution for G{\"o}del's System T. This
amounts to shifting our attention from defining a semantics for
expressions, to defining a semantics for canonicals, where we
fortuitously get to reuse the same Kripke model.

}


\todo[inline]{Notational conventions}

\todo[inline]{intro:}
\todo[inline]{semantics of expressions vs semantics of canonicals}
\todo[inline]{analogy with intrinsic typing and forward reference theorems saved below}
\todo[inline]{rather than come up with predicate for hsub, reuse kripke model!}

\todo[inline]{Intrinsic typing does not need type preservation}
\todo[inline]{Intrinsic semantics does not determinacy of relation}
\todo[inline]{Intrinsic semantics does not need model preservation}
\todo[inline]{Intrinsic semantics needs mono (wkn pres) model, but not mono theory}

\todo[inline]{We show proof savings when moving from realiz pred (unary logrel) to kripke model (nullary logrel)}
\todo[inline]{Model preservation is way to thread extrinsic semantics through}
\todo[inline]{Kripke model reify now does very little}
\todo[inline]{Defn/semantics of eval/ceval very close to bigstep/hsub relation}
\todo[inline]{Speculate saving similiar extrinsic hsub theorem as bigstep with predicate}

\todo[inline]{logrel/hsub relation sections:}
\todo[inline]{motivate model defn with how termination fails in application}

\todo[inline]{last part is sub with env of values and returning a value}
\todo[inline]{final part of expr norm via hsub, NbHSbCE}

\begin{figure}
\caption{
BNF grammar for {\it types} and {\it contexts}. 
Expressions, values, and neutrals
are not represented by a BNF grammar. Instead, they are defined by
an intrinsically typed representation, rather than a BNF grammar and
an extrinsic typing relation over said grammar.
}
\begin{align*}
A, B, C &::= \nat ~ | ~ A \arr B \\
\Gamma, \Delta, \Xi &::= \epsilon ~ | ~ \Gamma , A
\end{align*}
\label{fig:gram}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of De Bruijn {\it variables}.
The intrinsically typed variables act as proofs that the type
parameter of the judgment appears in the context parameter of the
judgement.
}
$$
\infer
  [\con{here}]
  {\ctypr{A}{A}}
{
}
\qquad
\infer
  [\con{there} ~ i]
  {\ctypr{B}{A}}
{
  (i : \typr{A})
}
$$
\label{fig:typr}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of {\it expressions} for G{\"o}del's System T. The
intrinsically typed expressions act as proofs that the expression
represented by the proof term is well typed.
}
$$
\infer
  [\con{zero}]
  {\type{\nat}}
{}
\qquad
\infer
  [\con{suc} ~ n]
  {\type{\nat}}
{
  (n : \type{\nat})
}
$$

$$
\infer
  [\lam b]
  {\type{A \arr B}}
{
  (b : \ctype{A}{B})
}
\qquad
\infer
  [\fun{var} ~ i]
  {\type{A}}
{
  (i : \typr{A})
}
$$

$$
\infer
  [f \app a]
  {\type{B}}
{
  (f : \type{A \arr B})
  &
  (a : \type{A \arr B})
}
$$

$$
\infer
  [\fun{rec} ~ n ~ c_z ~ c_s]
  {\type{C}}
{
  (n : \type{\nat})
  &
  (c_z : \type{C})
  &
  (c_s : \type{C \arr C})
}
$$
\label{fig:type}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of {\it values} (canonical terms) for G{\"o}del's System T.
The intrinsically typed values act as proofs that the value
represented by the proof term is well typed. The grammar of values
also includes all neutral terms.
}
$$
\infer
  [\con{zero}]
  {\typv{\nat}}
{}
\qquad
\infer
  [\con{suc} ~ n]
  {\typv{\nat}}
{
  (n : \typv{\nat})
}
$$

$$
\infer
  [\lam b]
  {\typv{A \arr B}}
{
  (b : \ctypv{A}{B})
}
\qquad
\infer
  [\fun{neut} ~ a]
  {\typv{A}}
{
  (a : \typn{A})
}
$$
\label{fig:typv}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of {\it neutrals} (variables and elimination rules) 
for G{\"o}del's System T.
The intrinsically typed neutrals act as proofs that the neutral
represented by the proof term is well typed.
}

$$
\infer
  [\fun{var} ~ i]
  {\typn{A}}
{
  (i : \typr{A})
}
$$

$$
\infer
  [f \app a]
  {\typn{B}}
{
  (f : \typn{A \arr B})
  &
  (a : \typv{A \arr B})
}
$$

$$
\infer
  [\fun{rec} ~ n ~ c_z ~ c_s]
  {\typn{C}}
{
  (n : \typn{\nat})
  &
  (c_z : \typv{C})
  &
  (c_s : \typv{C \arr C})
}
$$
\label{fig:typn}
\end{figure}

\todo[inline]{In pictures put (e) around predicates, and superscript A
for E and V}

\todo[inline]{Future work: state (via worlds), exceptions (via monad)}

\section{Related Work}

Our termination proof is a novel model-theoretic result, but it
does not solve the proof-theoretic version of the same problem.
Nevertheless, we view our solution as somewhere in between a largely
model theoretic, and proof theoretic semantics, as it is a syntactic
model (rather than HA or CCC).

%% \appendix

\acks

We would like to thank Andrew Cave for helping us understand subtle
issues encountered when formalizing termination proofs.
This work was supported by NSF/CISE/CCF grant \#1320934.

\bibliographystyle{abbrvnat}
\bibliography{sbe}

\end{document}
