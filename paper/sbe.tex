\documentclass[preprint,nonatbib]{sigplanconf}
\usepackage[authoryear,square]{natbib}
\usepackage{proof}

\usepackage{todonotes}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{comment}
\usepackage{url}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{stmaryrd}
\usepackage{enumitem}
\usepackage[all]{xy}

\usepackage{float}
\floatstyle{boxed}
\restylefloat{figure}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
\DeclareUnicodeCharacter{8759}{\ensuremath{\colon\colon}}
\DeclareUnicodeCharacter{12314}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{12315}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{8614}{\ensuremath{\mapsto}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{?}{=}}}
\DeclareUnicodeCharacter{8669}{\ensuremath{\leadsto}}

\DeclareUnicodeCharacter{7496}{\ensuremath{^{d}}}

\usepackage{fancyvrb}

\usepackage[labelfont=bf]{caption}

\newtheorem{mydfn}{Definition}
\newtheorem{mysubdfn}{Case}
\numberwithin{mysubdfn}{mydfn}

\newtheorem{mythm}{Theorem}
\newtheorem{mylem}{Lemma}

\newcommand{\refdef}[1]{Definition \ref{dfn:#1}}
\newcommand{\refthm}[1]{Theorem \ref{thm:#1}}
\newcommand{\reflem}[1]{Lemma \ref{lem:#1}}

\newtheorem{mydef}{Definition}
\newtheorem{myparte}{Part$_E$}
\newtheorem{myparti}{Part$_I$}

\newcommand{\reffig}[1]{Figure \ref{fig:#1}}
\newcommand{\refsec}[1]{Section \ref{sec:#1}}
\newcommand{\refparte}[1]{Part$_E$ \ref{parte:#1}}
\newcommand{\refparti}[1]{Part$_I$ \ref{parti:#1}}

\def\dfn{\mapsto}
\def\bigstep{\Downarrow}
\def\arr{\supset}
\def\marr{\rightarrow}
\def\app{\cdot}
\def\lam{\lambda}
\def\nat{\mathbb{N}}

\newcommand{\el}[1]{\llbracket ~ #1 ~ \rrbracket}

\newcommand{\con}[1]{\textmd{#1}}
\newcommand{\fun}[1]{\textmd{#1}}

\newcommand{\typm}[1]{\el{\Gamma \vdash #1}}
\newcommand{\dtypm}[1]{\el{\Delta \vdash #1}}
\newcommand{\ctypm}[2]{\el{\Gamma , #1 \vdash #2}}

\newcommand{\type}[1]{\Gamma \vdash^E #1}
\newcommand{\dtype}[1]{\Delta \vdash^E #1}
\newcommand{\ctype}[2]{\Gamma , #1 \vdash^E #2}

\newcommand{\typv}[1]{\Gamma \vdash^V #1}
\newcommand{\dtypv}[1]{\Delta \vdash^V #1}
\newcommand{\ctypv}[2]{\Gamma , #1 \vdash^V #2}

\newcommand{\typn}[1]{\Gamma \vdash^N #1}
\newcommand{\dtypn}[1]{\Delta \vdash^N #1}
\newcommand{\ctypn}[2]{\Gamma , #1 \vdash^N #2}

\newcommand{\typr}[1]{\Gamma \vdash^R #1}
\newcommand{\dtypr}[1]{\Delta \vdash^R #1}
\newcommand{\ctypr}[2]{\Gamma , #1 \vdash^R #2}

\newcommand{\ren}[1]{\Gamma \le #1}
\def\dren{\ren{\Delta}}
\newcommand{\env}[1]{\Gamma \sqsubseteq #1}
\def\denv{\env{\Delta}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\titlebanner{DRAFT}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Proof Pearl: Hereditary Substitution by Canonical Evaluation}
\subtitle{Termination Proofs as Intrinsic Semantics}

\authorinfo{Larry Diehl\and Tim Sheard}
           {Portland State University}
           {\{ldiehl,sheard\}@cs.pdx.edu}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis
adipiscing ligula ac metus tempus, ut fermentum nunc commodo. In
egestas dui vitae enim rhoncus volutpat. Nulla id ullamcorper est.
Nulla congue vitae eros vitae consectetur. Vivamus nunc orci,
tincidunt eget sem non, facilisis rhoncus lectus. Pellentesque
pharetra sapien eu lacus vulputate, eget ultricies sapien feugiat.
Fusce dapibus, augue non commodo vulputate, enim nibh ultrices massa,
at pharetra urna mi et ante. Aenean et fermentum erat. Fusce a magna
arcu.
\end{abstract}

\category{D.3}{Software}{Programming Languages}.

\keywords
Type theory; hereditary substitution; termination; formalization; dependent types.

\section{Introduction}
\label{sec:intro}

It is standard practice to write generic functions in a dependently
typed language by using a \citet{martin1975intuitionistic} universe.
A universe consists of codes representing types, and an interpretation
function that translates a code into an actual type. It is possible to
write a function that is generic for all encoded types by taking a
universe code argument, followed by an argument whose dependent type
is the interpretation of said code. For example, below is a function
({\tt decimal}) that computes the decimal value of a binary number, which
is generic in the length of the binary number.

\begin{displaymath}
    \xymatrix{
          {\forall (e : A)} 
          \ar[dr]_{\fun{norm}}
          \ar[r]^{\fun{eval}}
        & {\el{A}}
          \ar[d]^{\large{\fun{reify}}}
\\      & {\exists (e' : A). ~ e \bigstep e' \wedge \fun{IsNormal} ~ e'} }
\end{displaymath}

\begin{displaymath}
    \xymatrix{
          {A} 
          \ar[dr]_{\fun{norm}}
          \ar[r]^{\fun{eval}}
        & {\el{A}}
          \ar[d]^{\large{\fun{reify}}}
\\      & {A} }
\end{displaymath}


\begin{displaymath}
    \xymatrix{
          {\forall (v : A), \sigma} 
          \ar[dr]_{\fun{hsub}}
          \ar[r]^{\fun{ceval}}
        & {\el{A}}
          \ar[d]^{\large{\fun{reify}}}
\\      & {\exists (v' : A). ~ [ \sigma ] v = v'} }
\end{displaymath}

\begin{displaymath}
    \xymatrix{
          {A, \sigma} 
          \ar[dr]_{\fun{hsub}}
          \ar[r]^{\fun{ceval}}
        & {\el{A}}
          \ar[d]^{\large{\fun{reify}}}
\\      & {A} }
\end{displaymath}

\begin{mydfn}[Big-Step Realizability Predicate]
$ $\\
For any context $\Gamma$ and type $A$, the predicate on the expression
$(a : \type{A})$ is $\typm{A}(a)$.

\begin{mysubdfn}[Natural numbers]
$\typm{\nat}(n)$
$$
\exists (n' : \type{\nat}).~ n \bigstep n' \wedge \fun{IsNormal} ~ n'
$$
For natural numbers we require a proof that $n$ evalutes to
some normal term $n'$ .
\end{mysubdfn}


\begin{mysubdfn}[Functions]
$\typm{A \arr B}(f)$
\begin{align*}
\forall \Delta.&~ \dren \marr (a : \dtype{A}) \marr \\
&\dtypm{A}(a) \marr \dtypm{B}(\fun{ren}^E ~ \Delta ~ f \app a)
\end{align*}


%% $$
%% \forall \Delta.~ \dren \marr (a : \dtype{A})
%% \marr \dtypm{A}(a) \marr \dtypm{B}(\fun{ren}^E ~ \Delta ~ f \app a)
%% $$

For functions we require that for any weakened proof that $a$
is realized, a proof that a weakened version of $f$ applied to
$a$ is also realized.
\end{mysubdfn}

\end{mydfn}

\begin{mythm}[Predicate Reflection]
$$\forall (a : \type{A}).~ \fun{IsNeutral} ~ a \marr \typm{A}(a)$$
\end{mythm}

\begin{mythm}[Predicate Preservation]
$$
\forall (a ~ a' : \type{A}).~ \typm{A}(a) \marr 
a \bigstep a' \marr \typm{A}(a')
$$
\end{mythm}

\begin{mythm}[Predicate Reification]
$$
\forall (a : \type{A}).~ \typm{A}(a) \marr
\exists (a' : \type{A}).~ a \bigstep a' ~ \wedge ~ \fun{IsNormal} ~ a'
$$
\end{mythm}

\begin{mythm}[Predicate Evaluation]
$$
\forall (a : \type{A}) (\sigma : \denv).~ \dtypm{A}(\sigma ~ a)
$$
\end{mythm}




\begin{align*}
&\typm{A \arr B}& &\dfn \forall \Delta.~ \dren \marr \dtypm{A} \marr \dtypm{B} \\
&\typm{A}& &\dfn \typv{A}
\end{align*}




%% \begin{displaymath}
%%     \xymatrix{
%%           {\forall (v : \typv{A}) (\sigma : \denv)} \ar[dr] 
%%             \ar[r]
%%         & {\dtypm{A}} \ar[d]
%% \\      & {\exists (v' : \dtypv{A}). ~ [ \sigma ] v = v'} }
%% \end{displaymath}

\todo[inline]{Notational conventions}

\todo[inline]{intro:}
\todo[inline]{semantics of expressions vs semantics of canonicals}
\todo[inline]{analogy with intrinsic typing and forward reference theorems saved below}
\todo[inline]{rather than come up with predicate for hsub, reuse kripke model!}

\todo[inline]{Intrinsic typing does not need type preservation}
\todo[inline]{Intrinsic semantics does not determinacy of relation}
\todo[inline]{Intrinsic semantics does not need model preservation}
\todo[inline]{Intrinsic semantics needs mono (wkn pres) model, but not mono theory}

\todo[inline]{We show proof savings when moving from realiz pred (unary logrel) to kripke model (nullary logrel)}
\todo[inline]{Model preservation is way to thread extrinsic semantics through}
\todo[inline]{Kripke model reify now does very little}
\todo[inline]{Defn/semantics of eval/ceval very close to bigstep/hsub relation}
\todo[inline]{Speculate saving similiar extrinsic hsub theorem as bigstep with predicate}

\todo[inline]{logrel/hsub relation sections:}
\todo[inline]{motivate model defn with how termination fails in application}

\todo[inline]{last part is sub with env of values and returning a value}

\begin{figure}
\caption{
BNF grammar for {\it types} and {\it contexts}. 
Expressions, values, and neutrals
are not represented by a BNF grammar. Instead, they are defined by
an intrinsically typed representation, rather than a BNF grammar and
an extrinsic typing relation over said grammar.
}
\begin{align*}
A, B, C &::= \nat ~ | ~ A \arr B \\
\Gamma, \Delta, \Xi &::= \epsilon ~ | ~ \Gamma , A
\end{align*}
\label{fig:gram}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of De Bruijn {\it variables}.
The intrinsically typed variables act as proofs that the type
parameter of the judgment appears in the context parameter of the
judgement.
}
$$
\infer
  [\con{here}]
  {\ctypr{A}{A}}
{
}
\qquad
\infer
  [\con{there} ~ i]
  {\ctypr{B}{A}}
{
  (i : \typr{A})
}
$$
\label{fig:typr}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of {\it expressions} for G{\"o}del's System T. The
intrinsically typed expressions act as proofs that the expression
represented by the proof term is well typed.
}
$$
\infer
  [\con{zero}]
  {\type{\nat}}
{}
\qquad
\infer
  [\con{suc} ~ n]
  {\type{\nat}}
{
  (n : \type{\nat})
}
$$

$$
\infer
  [\lam b]
  {\type{A \arr B}}
{
  (b : \ctype{A}{B})
}
\qquad
\infer
  [\fun{var} ~ i]
  {\type{A}}
{
  (i : \typr{A})
}
$$

$$
\infer
  [f \app a]
  {\type{B}}
{
  (f : \type{A \arr B})
  &
  (a : \type{A \arr B})
}
$$

$$
\infer
  [\fun{rec} ~ n ~ c_z ~ c_s]
  {\type{C}}
{
  (n : \type{\nat})
  &
  (c_z : \type{C})
  &
  (c_s : \type{C \arr C})
}
$$
\label{fig:type}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of {\it values} (canonical terms) for G{\"o}del's System T.
The intrinsically typed values act as proofs that the value
represented by the proof term is well typed. The grammar of values
also includes all neutral terms.
}
$$
\infer
  [\con{zero}]
  {\typv{\nat}}
{}
\qquad
\infer
  [\con{suc} ~ n]
  {\typv{\nat}}
{
  (n : \typv{\nat})
}
$$

$$
\infer
  [\lam b]
  {\typv{A \arr B}}
{
  (b : \ctypv{A}{B})
}
\qquad
\infer
  [\fun{neut} ~ a]
  {\typn{A}}
{
  (a : \typn{A})
}
$$
\label{fig:typv}
\end{figure}

\begin{figure}
\caption{
Intrinsic typing of {\it neutrals} (variables and elimination rules) 
for G{\"o}del's System T.
The intrinsically typed neutrals act as proofs that the neutral
represented by the proof term is well typed.
}

$$
\infer
  [\fun{var} ~ i]
  {\typn{A}}
{
  (i : \typr{A})
}
$$

$$
\infer
  [f \app a]
  {\typn{B}}
{
  (f : \typn{A \arr B})
  &
  (a : \typv{A \arr B})
}
$$

$$
\infer
  [\fun{rec} ~ n ~ c_z ~ c_s]
  {\typn{C}}
{
  (n : \typn{\nat})
  &
  (c_z : \typv{C})
  &
  (c_s : \typv{C \arr C})
}
$$
\label{fig:typn}
\end{figure}

%% \appendix

\acks

We would like to thank Andrew Cave for helping us understand subtle
issues encountered when formalizing termination proofs.
This work was supported by NSF/CISE/CCF grant \#1320934.

\bibliographystyle{abbrvnat}
\bibliography{sbe}

\end{document}
